package pt.ulisboa.tecnico.sdis.kerby.cli;

import static javax.xml.ws.BindingProvider.ENDPOINT_ADDRESS_PROPERTY;

import java.util.Map;
import java.util.Random;

import javax.xml.ws.BindingProvider;

import com.sun.xml.ws.client.ClientTransportException;
import pt.ulisboa.tecnico.sdis.kerby.*;

/**
 * Client port wrapper.
 *
 * Adds easier end point address configuration to the Port generated by
 * wsimport.
 */
public class KerbyClient{

	/** WS service */
	KerbyService service = null;

	/** WS port (port type is the interface, port is the implementation) */
	KerbyPortType port = null;


	/** WS name */
	private String wsName = null;

	/** WS end point address */
	private String wsURL = null; // default value is defined inside WSDL

	public String getWsURL() {
		return wsURL;
	}

	/** output option **/
	private boolean verbose = false;

	/** constructor with provided web service URL */
	public KerbyClient(String wsURL) {
		this.wsURL = wsURL;
		createStub();
	}

	/** Stub creation and configuration */
	private void createStub() {
		service = new KerbyService();
		port = service.getKerbyPort();

		if (wsURL != null) {
			BindingProvider bindingProvider = (BindingProvider) port;
			Map<String, Object> requestContext = bindingProvider.getRequestContext();
			requestContext.put(ENDPOINT_ADDRESS_PROPERTY, wsURL);
		}
	}


	public SessionKeyAndTicketView requestTicket(String client, String server, long nounce, int ticketDuration)
			throws BadTicketRequest_Exception{
        while(true){
            try{
                return port.requestTicket(client, server, nounce, ticketDuration);
            }catch(ClientTransportException cte){
                try{
                    printKerbyUnreacheableErrorMessage();
                    Thread.sleep(1000);
                } catch(InterruptedException e){
                    e.printStackTrace();
                }
                continue;
            }
        }
	}

    public void revokeKey(String keyOwner) {
        while(true){
            try{
                port.revokeKey(keyOwner);
                break;
            }catch(ClientTransportException cte){
                try{
                    printKerbyUnreacheableErrorMessage();
                    Thread.sleep(1000);
                } catch(InterruptedException e){
                    e.printStackTrace();
                }
                continue;
            }
        }

    }

    public String generateDHPassword(String client){
        Random rand = new Random();
        // generate public ints to be shared, base g, and modulus p
        int g = rand.nextInt(10000) + 100;
        int p = rand.nextInt(10000) + 10;

        // generate our secret value
        int myPower = rand.nextInt(10000);
        int valueToShare = ((int) Math.pow(g, myPower)) % p;

        int serverValue;
        while(true){
            try{
                serverValue = port.generateDHPassword(client, valueToShare, g, p);
                break;
            }catch(ClientTransportException cte){
                try{
                    printKerbyUnreacheableErrorMessage();
                    Thread.sleep(1000);
                } catch(InterruptedException e){
                    e.printStackTrace();
                }
                continue;
            }
        }

        int finalValue = ((int) Math.pow(serverValue, myPower)) % p;
        System.err.println(client + " : Generated DH number: " + finalValue);

        return Integer.toString(finalValue);
    }

    private void printKerbyUnreacheableErrorMessage(){
	    System.err.println("Kerby-ws is unreacheable, retrying...");
    }

}
